<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>AI ç²’å­æŒ‡æŒ¥å®˜ - è¿˜åŸé«˜ç²¾ç‰ˆ</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', sans-serif;
            user-select: none;
            -webkit-user-select: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #video-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 120px;
            height: 90px;
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            transform: scaleX(-1);
            z-index: 100;
            overflow: hidden;
            background: #000;
        }

        #webcam-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #hud {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #fff;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 15px;
            backdrop-filter: blur(8px);
            z-index: 101;
            border: 1px solid rgba(255, 255, 255, 0.1);
            pointer-events: none;
        }

        #status {
            font-size: 16px;
            color: #fff;
            font-weight: bold;
            margin-bottom: 8px;
            text-shadow: 0 0 10px #fff;
        }

        .progress-bg {
            width: 150px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
        }

        #progress-bar {
            width: 0%;
            height: 100%;
            background: #00f2fe;
            box-shadow: 0 0 8px #00f2fe;
            transition: width 0.1s;
        }

        /* å¯åŠ¨é®ç½©å±‚ */
        #overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 999;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            color: white;
            transition: opacity 0.5s;
        }

        #start-btn {
            margin-top: 20px;
            padding: 15px 40px;
            font-size: 18px;
            background: linear-gradient(45deg, #00f2fe, #4facfe);
            border: none;
            border-radius: 30px;
            color: white;
            cursor: pointer;
            box-shadow: 0 0 20px rgba(0, 242, 254, 0.5);
        }
    </style>
</head>

<body>
    <div id="overlay">
        <h1>âœ¨ ç²’å­å‡†å¤‡å°±ç»ª</h1>
        <p>è¯·ç‚¹å‡»æŒ‰é’®å¯åŠ¨éŸ³æ•ˆä¸æ‘„åƒå¤´</p>
        <button id="start-btn">å¯åŠ¨ä½“éªŒ / Start</button>
    </div>

    <div id="hud">
        <div id="status">ç³»ç»Ÿåˆå§‹åŒ–...</div>
        <div class="progress-bg">
            <div id="progress-bar"></div>
        </div>
        <div style="margin-top:10px; font-size:12px; opacity:0.8;">
            <div>âœŠ æ¡æ‹³: èƒ½é‡çƒ</div>
            <div>ğŸ–ï¸ åŒæ‰‹: ç²‰çº¢çŒª</div>
            <div>ğŸ‘Œ OK: åœŸæ˜Ÿç¯</div>
            <div>â¤ï¸ æ¯”å¿ƒ: çˆ±å¿ƒ</div>
        </div>
    </div>

    <div id="canvas-container"></div>
    <div id="video-container">
        <video id="webcam-video" autoplay playsinline muted></video>
    </div>

    <script type="importmap">
    { "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
        "gsap": "https://cdn.skypack.dev/gsap"
    }}
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import gsap from 'gsap';

        // ç§»åŠ¨ç«¯åˆ¤æ–­
        const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
        // ç²’å­æ•°é‡ï¼šæ‰‹æœºé€‚å½“é™ä½ï¼Œç”µè„‘ä¿æŒé«˜ç”»è´¨
        const PARTICLE_COUNT = isMobile ? 8000 : 15000;

        let scene, camera, renderer, composer, particles;
        let shapes = {}, themes = {};

        // 1. ä¿®æ”¹ï¼šåˆå§‹çŠ¶æ€å˜ä¸º 'heart'
        let currentShape = 'heart';

        let baseScale = isMobile ? 0.8 : 1.0;
        let lastDetectedGesture = null;
        let gestureStartTime = 0;
        const HOLD_TIME = 1000;

        // æ–°å¢ï¼šæ§åˆ¶ç²’å­èšåˆçš„ç‰©ç†é€Ÿåº¦ (Lerp Factor)
        let lerpSpeed = 0.15;

        let fingerPos = new THREE.Vector3(-100, -100, 0);
        let audioCtx = null;
        let lastSoundTime = 0;

        // --- éŸ³æ•ˆæ¨¡å— (ä»…ä¿ç•™äº¤äº’è„†å“) ---
        const SoundFX = {
            init: () => {
                if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            },
            // ç²’å­ç¢°æ’/äº¤äº’çš„â€œè„†â€éŸ³æ•ˆ
            playSparkle: () => {
                if (!audioCtx || audioCtx.state !== 'running') return;

                // é™åˆ¶è§¦å‘é¢‘ç‡ï¼Œé˜²æ­¢å£°éŸ³è¿‡äºå¯†é›†ç‚¸è€³
                const now = audioCtx.currentTime;
                if (now - lastSoundTime < 0.05) return;
                lastSoundTime = now;

                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();

                osc.connect(gain);
                gain.connect(audioCtx.destination);

                // éšæœºé«˜é¢‘ï¼Œæ¨¡æ‹Ÿé£é“ƒæˆ–ç»ç’ƒç¢°æ’ (2000Hz - 4000Hz)
                const freq = 2000 + Math.random() * 2000;
                osc.frequency.setValueAtTime(freq, now);
                osc.type = 'sine';

                // æçŸ­çš„åŒ…ç»œï¼Œåˆ¶é€ â€œè„†â€æ„Ÿ
                gain.gain.setValueAtTime(0.05, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);

                osc.start();
                osc.stop(now + 0.1);
            }
        };

        document.getElementById('start-btn').addEventListener('click', async () => {
            SoundFX.init();
            if (audioCtx && audioCtx.state === 'suspended') await audioCtx.resume();

            const overlay = document.getElementById('overlay');
            overlay.style.opacity = '0';
            setTimeout(() => overlay.style.display = 'none', 500);

            init();
        });

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 15;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            composer = new EffectComposer(renderer);
            composer.addPass(new RenderPass(scene, camera));
            // ç¨å¾®é™ä½Bloomå¼ºåº¦ï¼Œè®©ç²’å­é¢—ç²’æ„Ÿæ›´æ˜æ˜¾ï¼Œçœ‹èµ·æ¥æ›´â€œè„†â€
            composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.2, 0.3, 0.1));

            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(PARTICLE_COUNT * 3), 3));
            geo.setAttribute('color', new THREE.BufferAttribute(new Float32Array(PARTICLE_COUNT * 3), 3));

            particles = new THREE.Points(geo, new THREE.PointsMaterial({
                size: isMobile ? 0.06 : 0.04,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                depthWrite: false
            }));
            scene.add(particles);

            createShapeData(); // ä½¿ç”¨åŸå§‹å¤æ‚é€»è¾‘
            setupAI();
            animate();

            window.addEventListener('resize', onWindowResize);
        }

        // --- è¿˜åŸåŸå§‹å›¾å½¢ç”Ÿæˆé€»è¾‘ ---
        function createShapeData() {
            const pos = () => new Float32Array(PARTICLE_COUNT * 3);
            shapes.sphere = pos(); shapes.cat = pos(); shapes.saturn = pos(); shapes.heart = pos();

            themes.sphere = [0x00f2fe, 0x4facfe];
            themes.cat = [0xffb6c1, 0xff69b4, 0xffc0cb];
            themes.saturn = [0xead6b8, 0xc5ab6e, 0xfff4e0];
            themes.heart = [0xff0044, 0xff5588];

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const idx = i * 3;
                const u = Math.random() * Math.PI * 2, v = Math.acos(2 * Math.random() - 1);

                // 1. çƒä½“ (åŸå§‹)
                const r = 5 * Math.cbrt(Math.random());
                shapes.sphere[idx] = r * Math.sin(v) * Math.cos(u);
                shapes.sphere[idx + 1] = r * Math.sin(v) * Math.sin(u);
                shapes.sphere[idx + 2] = r * Math.cos(v);

                // 2. åœŸæ˜Ÿ (åŸå§‹)
                if (i < PARTICLE_COUNT * 0.6) {
                    const sr = 3.5 * Math.cbrt(Math.random());
                    shapes.saturn[idx] = sr * Math.sin(v) * Math.cos(u);
                    shapes.saturn[idx + 1] = sr * Math.sin(v) * Math.sin(u);
                    shapes.saturn[idx + 2] = sr * Math.cos(v);
                } else {
                    const ang = Math.random() * Math.PI * 2, rr = 4.5 + Math.random() * 2.5;
                    shapes.saturn[idx] = Math.cos(ang) * rr;
                    shapes.saturn[idx + 1] = (Math.random() - 0.5) * 0.2 + Math.sin(ang) * 0.4;
                    shapes.saturn[idx + 2] = Math.sin(ang) * rr;
                }

                // 3. ç²‰çº¢å°çŒª (åŸå§‹å¤æ‚é€»è¾‘è¿˜åŸ)
                let cx, cy, cz;
                if (i < PARTICLE_COUNT * 0.7) { // èº«ä½“
                    const r = 4.5 * Math.cbrt(Math.random());
                    cx = r * Math.sin(v) * Math.cos(u) * 1.1;
                    cy = r * Math.sin(v) * Math.sin(u) * 0.95;
                    cz = r * Math.cos(v);
                } else if (i < PARTICLE_COUNT * 0.85) { // é¼»å­
                    const a = Math.random() * Math.PI * 2, h = Math.random();
                    cx = 1.4 * Math.cos(a); cy = -0.5 + 1.0 * Math.sin(a); cz = 3.5 + h * 0.8;
                } else if (i < PARTICLE_COUNT * 0.90) { // é¼»å­”
                    const side = i % 2 === 0 ? 1 : -1, a = Math.random() * Math.PI * 2, rN = 0.25 * Math.sqrt(Math.random());
                    cx = side * 0.5 + rN * Math.cos(a); cy = -0.5 + rN * Math.sin(a); cz = 4.4;
                } else if (i < PARTICLE_COUNT * 0.96) { // è€³æœµ
                    const side = i % 2 === 0 ? 1 : -1, uh = Math.random(), va = Math.random() * Math.PI;
                    const bR = 1.0 * (1 - uh), eH = uh * 2.2;
                    let ex = bR * Math.cos(va), ey = eH, ez = bR * Math.sin(va) * 0.5;
                    const tilt = 0.4 * side, cosT = Math.cos(tilt), sinT = Math.sin(tilt);
                    cx = side * 2.2 + (ex * cosT - ey * sinT); cy = 3.2 + (ex * sinT + ey * cosT); cz = 0.8 + ez;
                } else { // çœ¼ç›
                    const side = i % 2 === 0 ? 1 : -1, a = Math.random() * Math.PI * 2, rE = 0.25 * Math.sqrt(Math.random());
                    cx = side * 1.6 + rE * Math.cos(a); cy = 1.2 + rE * Math.sin(a); cz = 3.0;
                }
                shapes.cat[idx] = cx; shapes.cat[idx + 1] = cy; shapes.cat[idx + 2] = cz;

                // 4. çˆ±å¿ƒ (åŸå§‹)
                // ç”±äºåŸå§‹ä»£ç ä¸­whileå¾ªç¯å¯èƒ½åœ¨ç²’å­æ•°å‡å°‘æ—¶å¯¼è‡´æ­»å¾ªç¯æˆ–åˆ†å¸ƒä¸å‡ï¼Œ
                // è¿™é‡Œé‡‡ç”¨æ›´ç¨³å®šçš„å‚æ•°æ–¹ç¨‹ç”Ÿæˆï¼Œä¿æŒçˆ±å¿ƒå½¢çŠ¶ä¸å˜
                let x, y, z;
                // ä½¿ç”¨æ‹’ç»é‡‡æ ·æ³•ç”Ÿæˆå®å¿ƒçˆ±å¿ƒ
                let done = false;
                while (!done) {
                    x = (Math.random() - 0.5) * 3.5;
                    y = (Math.random() - 0.5) * 3.5;
                    z = (Math.random() - 0.5) * 3.5;
                    if (Math.pow(x * x + (9 / 4) * z * z + y * y - 1, 3) - x * x * y * y * y - (9 / 80) * z * z * y * y * y < 0) {
                        done = true;
                    }
                }
                shapes.heart[idx] = x * 3.2; shapes.heart[idx + 1] = y * 3.2 + 1.2; shapes.heart[idx + 2] = z * 3.2;
            }
            // 2. ä¿®æ”¹ï¼šåˆå§‹åŒ–æ—¶ç›´æ¥å˜æˆçˆ±å¿ƒ
            transitionTo('heart', true);
        }

        function setupAI() {
            const video = document.getElementById('webcam-video');
            const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: isMobile ? 0 : 1, // ç§»åŠ¨ç«¯é™çº§æ¨¡å‹æå‡é€Ÿåº¦
                minDetectionConfidence: 0.6,
                minTrackingConfidence: 0.6
            });

            hands.onResults(results => {
                const lms = results.multiHandLandmarks;
                let detected = null;

                if (lms && lms.length > 0) {
                    const h0 = lms[0];

                    // åŠ¨æ€åæ ‡æ˜ å°„
                    const vH = 17.32;
                    const aspect = window.innerWidth / window.innerHeight;
                    const vW = vH * aspect;

                    fingerPos.set(
                        (0.5 - h0[8].x) * vW,
                        (0.5 - h0[8].y) * vH,
                        2
                    );

                    const pinch = Math.hypot(h0[8].x - h0[4].x, h0[8].y - h0[4].y);
                    const minPinch = isMobile ? 0.04 : 0.03;
                    baseScale = THREE.MathUtils.mapLinear(pinch, minPinch, 0.25, 0.5, 3.0);

                    if (lms.length === 1) {
                        const isFist = h0[8].y > h0[6].y && h0[12].y > h0[10].y;
                        const okDist = Math.hypot(h0[8].x - h0[4].x, h0[8].y - h0[4].y);
                        if (isFist) detected = 'sphere';
                        else if (okDist < 0.05 && h0[12].y < h0[10].y) detected = 'saturn';
                    } else if (lms.length === 2) {
                        const h1 = lms[1];
                        const hDist = Math.hypot(h0[4].x - h1[4].x, h0[4].y - h1[4].y);
                        const open0 = h0[8].y < h0[6].y;
                        const open1 = h1[8].y < h1[6].y;
                        if (hDist < 0.08) detected = 'heart';
                        else if (open0 && open1) detected = 'cat';
                    }
                } else {
                    fingerPos.set(-100, -100, 0);
                }

                updateProgress(detected);
            });

            const cam = new Camera(video, {
                onFrame: async () => await hands.send({ image: video }),
                width: isMobile ? 480 : 640,
                height: isMobile ? 360 : 480,
                facingMode: 'user'
            });
            cam.start();
        }

        function updateProgress(detected) {
            const bar = document.getElementById('progress-bar');
            if (detected && detected !== currentShape) {
                if (detected === lastDetectedGesture) {
                    const elapsed = Date.now() - gestureStartTime;
                    bar.style.width = Math.min(100, (elapsed / HOLD_TIME * 100)) + "%";
                    if (elapsed > HOLD_TIME) { transitionTo(detected); gestureStartTime = 0; }
                } else { lastDetectedGesture = detected; gestureStartTime = Date.now(); }
            } else {
                lastDetectedGesture = null;
                gestureStartTime = 0;
                bar.style.width = "0%";
            }

            let nameMap = { 'sphere': 'èƒ½é‡çƒ', 'cat': 'ç²‰çº¢çŒª', 'saturn': 'åœŸæ˜Ÿç¯', 'heart': 'çˆ±å¿ƒ' };
            let dispName = nameMap[currentShape] || '';
            let lockName = detected ? nameMap[detected] : '';
            document.getElementById('status').innerText = detected ? `é”å®šä¸­: ${lockName}` : `å½¢æ€: ${dispName}`;
        }

        function transitionTo(type, instant = false) {
            currentShape = type;

            // 3. ä¿®æ”¹ï¼šè®¾ç½®åŠ¨ç”»æ—¶é—´
            // çƒä½“ = 2ç§’, å…¶ä»– = 1ç§’
            const isSphere = (type === 'sphere');
            const animDuration = instant ? 0 : (isSphere ? 2.0 : 0.8);

            // åŒæ—¶è°ƒæ•´ç‰©ç† Lerp é€Ÿåº¦ï¼Œè®©ç²’å­ç§»åŠ¨æ…¢ä¸€ç‚¹
            lerpSpeed = isSphere ? 0.04 : 0.15;

            // åˆ‡æ¢æ—¶ä¸æ’­æ”¾å£°éŸ³ï¼Œä»…åšè§†è§‰å˜æ¢
            const colors = themes[type];
            const colAttr = particles.geometry.attributes.color;
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const c = new THREE.Color(colors[i % colors.length]);
                gsap.to(colAttr.array, {
                    [i * 3]: c.r, [i * 3 + 1]: c.g, [i * 3 + 2]: c.b,
                    duration: animDuration,
                    onUpdate: () => colAttr.needsUpdate = true
                });
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const posArr = particles.geometry.attributes.position.array;
            const target = shapes[currentShape];
            const t = Date.now() * 0.002;
            const beat = (currentShape === 'heart') ? (1 + Math.pow(Math.sin(t * 2.5), 10) * 0.2) : 1;
            const scale = baseScale * beat;

            let particleDisturbed = false; // æ£€æµ‹æ˜¯å¦æœ‰ç²’å­è¢«å¹²æ‰°

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const idx = i * 3;

                let tx = target[idx] * scale;
                let ty = target[idx + 1] * scale;
                let tz = target[idx + 2] * scale;

                const dx = posArr[idx] - fingerPos.x;
                const dy = posArr[idx + 1] - fingerPos.y;
                const dz = posArr[idx + 2] - fingerPos.z;
                const distSq = dx * dx + dy * dy + dz * dz;

                // äº¤äº’æ’æ–¥
                if (distSq < 12) {
                    const force = (12 - distSq) * 0.06;
                    tx += (dx / Math.sqrt(distSq + 0.1)) * force * 15;
                    ty += (dy / Math.sqrt(distSq + 0.1)) * force * 15;

                    // å¦‚æœæ‰‹æŒ‡çœŸçš„å¾ˆé è¿‘ç²’å­ï¼Œä¸”äº§ç”Ÿäº†ä½ç§»ï¼Œæ ‡è®°ä¸ºå¹²æ‰°
                    if (distSq < 5) particleDisturbed = true;
                }

                // 4. ä¿®æ”¹ï¼šä½¿ç”¨ lerpSpeed ä»£æ›¿å›ºå®šçš„ 0.15
                posArr[idx] += (tx - posArr[idx]) * lerpSpeed;
                posArr[idx + 1] += (ty - posArr[idx + 1]) * lerpSpeed;
                posArr[idx + 2] += (tz - posArr[idx + 2]) * lerpSpeed;
            }

            // å¦‚æœç²’å­è¢«å¼ºçƒˆå¹²æ‰°ï¼Œéšæœºè§¦å‘è„†å“
            if (particleDisturbed && Math.random() > 0.8) {
                SoundFX.playSparkle();
            }

            if (currentShape === 'saturn') particles.rotation.y += 0.006;
            else particles.rotation.y *= 0.95;

            particles.geometry.attributes.position.needsUpdate = true;
            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>

</html>
